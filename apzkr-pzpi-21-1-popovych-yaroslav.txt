Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 
  
Факультет комп’ютерних наук 
  
Кафедра програмної інженерії 
  
КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: Програмна система для автоматизації доступу студентів та персоналу у камбузах
  	 	 
Студент гр. ПЗПІ-21-1    	________________ Попович Я.В. 
(підпис)  
Керівник роботи    	  
 
 	________________ доц. Лещинський В.О.  
(підпис)  
Роботу захищено «__»_________2024 р. з оцінкою _________________________  
Комісія: 	 	 	 	_________________ доц. Лещинський В.О.  
(підпис)  
                                                         _________________ доц. Лещинська І.О.    
(підпис)  
_________________ ст.викл. Сокорчук І.П. 
(підпис)  


Харків
2024 р. 
Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук Кафедра програмної інженерії______________ Спеціальність 121 – Інженерія програмного забезпечення_________________  
Курс ______3_______Семестр _________________6______________________  
Навчальна дисципліна  Архітектура програмного забезпечення____________ 
ЗАВДАННЯ 
НА КУРОСВУ РОБОТУ СТУДЕНТОВІ  
                                  Поповичу Ярославу Васильовичу                                _
1.	Тема проєкту: «Програмна система для автоматизації доступу студентів та персоналу у камбузах «eLock»»______________________________
2.	Термін узгодження завдання курсової роботи «29» березня 2024 р. 
3.	Термін здачі студентом закінченої роботи «10» червня 2024 р.  
4.	Вихідні дані до проєкту (роботи): Програмна система передбачає можливість створення камбузів, зон в камбузах, студентів, дверей, доступів, груп доступів, акаунтів адміністраторів, перевірки доступів студентів до дверей та пошук шляху від однієї зони камбузу до іншої. Використовувати ОС Windows 11, СКБД PostgreSQL, середовище розробки IntelliJ IDEA 2023.01, система контейнеризації Docker, identity provider Keycloak______________________________________________
5.	Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки_____________________________________________
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень): ER-діаграма бази даних, діаграма прецедентів серверної частини програмної системи, діаграма розгортання, діаграма компонентів для системи «eLock», діаграма прецедентів IoT частини, діаграма побудови IoT пристрою, діаграма пакетів IoT пристрою, діаграми взаємодії IoT системи, діаграма прецедентів для клієнтської частини системи «eLock», діаграма пакетів для клієнтської частини системи «eLock», діаграма компонентів для клієнтської частини системи «eLock», діаграма взаємодії для клієнтської частини системи «eLock», сторінка авторизації в адмін панелі Keycloak, сторінка з камбузами, сторінка із зонами камбузу, сторінка із дверима та доступами до них, сторінка з доступами, сторінка з групами доступів, сторінка з студентами, сторінка з логікою із демонстрацією пошуку шляху, сторінка із додатковою перевіркою на вихід з акаунту, сторінка Keycloak для головного адміністратора
 
КАЛЕНДАРНИЙ ПЛАН


№   	 	Назва етапів курсової роботи    	Термін виконання етапів роботи	Примітка   
1  	Функціональна специфікація програмного проекту  	13.04.2024 	виконано    
2  	Проектування програмного проекту  	30.04.2024 	виконано    
3  	Кодування програмного проекту  	20.05.2024  	виконано    
4  	Оформлення пояснювальної записки  	01.06.2024 	виконано    
5  	Захист курсової роботи  	08.06.2024  	виконано    

Дата видачі завдання «29» березня 2024 р.
  
Керівник                              ____________ доц. Лещинський В.О.				                                      (підпис)  

Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-1                      ____________             Попович Я. В.
     (підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 79 с., 24 рис., 2 табл., 2 додатки, 10 джерел. 
КАМБУЗ, СТУДЕНТ, ЗОНА, ПОШУК ШЛЯХУ, ПЕРЕВІРКА ДОСТУПІВ, ПРОГРАМНА СИСТЕМА, ГРУПИ ДОСТУПІВ, АДМІНІСТРУВАННЯ, УПРАВЛІННЯ, ЗАХИСТ, БЕЗПЕКА.
Об'єктом дослідження є програмна система автоматизації доступу студентів та персоналу в університетських камбузах з використанням сучасних технологій управління доступами та безпеки.
Метою курсової роботи є розробка програмної системи «eLock» для автоматизації доступу студентів та персоналу в університетських камбузах, що забезпечує ефективне управління доступами, підвищення безпеки та зручності користування. Система включає функціонал створення та адміністрування камбузів, зон, дверей, доступів, груп доступів, перевірки доступів студентів та пошуку шляху між зонами з урахуванням доступів на дверях та груп доступів у студента.
Методи розробки базуються на мові програмування Java та Spring Boot, що інтегруються з базою даних PostgreSQL через Spring Data JPA. Для клієнтської частини застосовано HTMX та Thymeleaf керування CSR та SSR. Інтерфейс розроблено за допомогою Bootstrap. Використано технології контейнеризації Docker, а Keycloak забезпечує управління автентифікацією та авторизацією. Для IoT частини застосовано мікроконтролери ESP32 з бібліотеками для роботи з серводвигунами, LCD-дисплеєм та клавіатурою, що інтегруються з основною системою через HTTP-запити.
У результаті роботи здійснено програмну реалізацію системи для автоматизації доступу студентів та персоналу у камбузах. Програмна система складається з клієнтської (веб додатку), сервера та IoT пристрою.
ЗМІСТ


ВСТУП	8
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1 Бізнес-вимоги	9
1.1.1 Бізнес-можливості	9
1.1.2 Бізнес-цілі та критерії успіху	10
1.1.3 Потреби клієнтів або ринку	10
1.1.4 Бізнес-ризики	11
1.2 Концепція рішення	12
1.2.1 Окреслення концепції	12
1.2.2 Головна функціональність	13
1.2.3 Припущення та залежності	13
1.3 Рамки та обмеження проєкту	14
1.3.1 Рамки первинного випуску	14
1.3.2 Рамки наступних випусків	15
1.3.3 Обмеження та винятки	16
1.4 Бізнес-контекст	18
1.4.1 Профілі зацікавлених сторін	18
1.4.2 Пріоритети проєкту	19
1.4.3 Робоче середовище	20
2 ПОСТАНОВКА ЗАДАЧІ	22
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ	23
3.1 Побудова ER-діаграми	23
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	25
4.1 Архітектура серверної частини	25
4.2 Архітектура IoT частини	28
4.3 Архітектура клієнтської частини	32
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ	38
5.1 Виклик і завантаження	38
5.2 Призначення і логічна структура	38
5.3 Опис програмної реалізації	40
ВИСНОВКИ	47
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	48
ДОДАТОК А	49
ДОДАТОК Б	50

 
ВСТУП


Університетські камбузи є живими спільнотами, що обслуговують значну кількість студентів, викладачів та персоналу. Забезпечення безпеки та ефективного управління доступом на таких територіях є ключовим завданням для забезпечення гармонійної роботи та навчання. Проблеми, пов’язані з контролем доступу, такі як крадіжки, несанкціоновані вторгнення та інші загрози, потребують надійного та сучасного рішення.
Проєкт «eLock» спрямований на вирішення цих проблем шляхом розробки інноваційної програмної системи для автоматизації контролю доступу в університетських камбузах. Основні цілі проєкту включають забезпечення високого рівня безпеки, ефективне управління доступом до різних зон камбузу та спосіб пошуку шляху до певної зони з врахування доступів користувачів.
Таким чином, «eLock» не лише вирішує існуючі проблеми контролю доступу, але й створює нові можливості для підвищення ефективності та безпеки університетських камбузів. Інноваційні підходи та використання передових технологій роблять цю систему потужним інструментом для сучасних навчальних закладів, здатним адаптуватися до змін і викликів майбутнього. 
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Університетські камбузи становлять значну частину ринку для систем контролю доступу та безпеки. З кожним роком зростає кількість університетів та їхніх студентів, що створює постійний попит на ефективні рішення з управління доступом.
Незважаючи на наявність різних систем контролю доступу на ринку, багато університетів стикаються з проблемами несвоєчасного виявлення або реагування на загрози безпеці, неефективного відстеження присутності людей на камбузі та складнощами управління різними рівнями доступу.
На ринку існують різноманітні продукти і рішення, такі як системи електронного доступу, біометричні системи та інтелектуальні системи контролю доступу. Проте багато з них можуть бути складними у використанні, обмеженими в можливостях або не забезпечують необхідний рівень безпеки та ефективності.
Програмна система «eLock» пропонує рішення, яке поєднує в собі сучасні технології забезпечення безпеки та ефективного управління доступом в університетських камбузах. 
Вона пропонує простий і зручний у використанні інтерфейс для керування доступом до дверей в камбузах та пропонує інформативну і гнучку систему управління доступом певних груп користувачів.




1.1.2 Бізнес-цілі та критерії успіху


BO-1: Запровадження програмної системи для автоматизації контролю доступу на університетських камбузах протягом наступних 12 місяців.
BO-2: Забезпечення безпеки камбузу шляхом ефективного виявлення та реагування на потенційні загрози.
BO-3: Підвищення ефективності управління доступом до приміщень та зон на камбузі.
BO-4: Забезпечення зручності та зменшення часу очікування для студентів, персоналу та відвідувачів під час входу на камбуз.
SC-1: Зменшення випадків порушень безпеки на камбузі на 20% протягом першого року використання системи.
SC-2: Підвищення швидкості та точності виявлення присутності осіб на камбузі на 30% протягом перших 6 місяців використання системи.
SC-3: Зменшення часу очікування на вхід/вихід на камбуз на 50% протягом перших 3 місяців роботи системи.
SC-4: Збільшення задоволення користувачів від процесу використання системи на 40% протягом першого року використання.


1.1.3 Потреби клієнтів або ринку


Система для автоматизації контролю доступу студентів та персоналу у камбузах буде обслуговувати різні зацікавлені сторони, тому варто рахуватись із потребами клієнтів, які включають:
−	ефективні засоби для контролю доступу на університетських камбузах з метою запобігання неправомірним входам та інцидентам безпеки
−	потребу у системі, що дозволяє точно відстежувати рух людей на камбузі для забезпечення безпеки
−	зручні та швидкі способи доступу до камбузу та його приміщень без зайвих затримок
−	простий та інтуїтивно зрозумілий інтерфейс
−	високу надійність та швидкодію
−	інструмент для гнучкого керування доступом для відповідальної за охорону людині
−	інструмент для пошуку шляху між зонами з урахуванням доступів користувачів


1.1.4 Бізнес-ризики


Запуск програмної системи для автоматизації контролю доступу на університетських камбузах може зіткнутися з рядом потенційних ризиків:
−	технічні проблеми: Можливі проблеми із сумісністю з існуючою інфраструктурою камбузу або нестабільна робота програмного забезпечення можуть призвести до непередбачуваних затримок у впровадженні та використанні системи
−	кібербезпека: ризик витоку конфіденційної інформації або злому системи може виникнути внаслідок недостатньої захищеності програмного забезпечення від кібератак
−	низька прийнятність користувачів: можливість, що користувачі не приймуть нову систему через складний інтерфейс або труднощі в її використанні
−	фінансові обмеження: обмежені фінансові ресурси клієнтів можуть затримати або ускладнити процес впровадження системи
Для зменшення ризиків потрібно ввести певні заходи, такі як:
−	проведення ретельного тестування перед впровадженням для виявлення та виправлення технічних проблем
−	розробка та впровадження ефективних заходів з кібербезпеки для захисту системи та конфіденційної інформації
−	дизайн інтерфейсу системи, що враховує потреби та зручність користувачів
−	розробка гнучких фінансових моделей або пропозицій зі спільним фінансуванням, щоб зробити систему доступною для клієнтів з різними фінансовими можливостями


1.2 Концепція рішення
1.2.1 Окреслення концепції


Наша концепція полягає в створенні інноваційної програмної системи, яка забезпечить безпеку та зручність управління доступом на університетських камбузах. Ми бачимо світ, де студенти, персонал та відвідувачі можуть вільно рухатися по камбузу, знаючи, що їхня безпека та приватність захищені, а процеси управління доступом оптимізовані для максимальної ефективності. Наша система сприятиме розвитку освіти та науки, створюючи сприятливе середовище для навчання та досліджень, що відповідає потребам сучасного світу.
 
1.2.2 Головна функціональність


Основні характеристики, які відрізнятимуть це рішення, включають:
MF-1: централізоване керування адміністраторами, камбузами, зонами, дверима, студентами, доступами до дверей, групами доступів студентів.
MF-2: інтеграція з пристроями інтернету речей для надавання доступу до приміщень користувачам із відповідним рівнем доступу.
MF-3: розбиття користувачів по групах та надання певних рівнів доступу всім користувачам груп.
MF-4: пошук шляху між зонами для певного користувача відповідно його групам доступу.
MF-5: надання функціоналу для відчинення дверей.
MF-6: інструменти для моніторингу та аналізу подій у системі.
MF-7: відстеження дій користувача.
MF-8: інтеграція з існуючими системами.


1.2.3 Припущення та залежності


A-1: проєкт передбачає існування необхідної апаратно-програмної інфраструктури для підтримки IoT-пристроїв;
A-2: припускається, що розробка та впровадження програмної системи буде фінансово підтримана;
A-3: користувачі будуть мати доступ до Інтернету для використання системи «eLock»;
A-4: припускається, що необхідні технічні можливості для реалізації функціональності системи будуть доступні;
D-1: проєкт залежить від успішної інтеграції зі сторонніми постачальниками апаратного забезпечення IoT;
D-2: проєкт може бути залежним від певних технологій або сервісів третіх сторін для реалізації певних функцій;
D-3: у разі співпраці з іншими розробниками або компаніями наявність та ефективність цієї співпраці може вплинути на успішність проєкту;
D-4: Реалізація деяких функцій може залежати від зовнішніх сервісів або API.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Програмна система складається із чотирьох компонентів: back-end, front-end, mobile app, IoT. Кожна частина взаємодіє з іншими для розширення функціоналу та утворення повноцінної екосистеми:
а)	Back-end
Серверна частина системи «eLock» приймає певні запити від користувачів та адміністраторів через веб-інтерфейс або мобільний застосунок і після чого серверна частина робить запити до бази даних та IoT пристрою для отримання інформації, необхідної для обробки запиту. І в кінці серверна частина повертає відповіді користувачам та вказує IoT пристрою надати доступ до приміщення. 
б)	Front-end
Клієнтська частина системи «eLock» розробляється з урахуванням потреб адміністраторів та відповідальних за безпеку в камбузі. Всі ці категорії мають різний рівень доступу та функціональності на платформі.
Для всіх адміністраторів: 
−	створити обліковий записи та увійти в систему;
−	зробити запит на доступ до керування доступом користувачів камбузу; 
−	є можливість додавати користувачів і доступи ним;
Додатково для відповідальних за безпеку: 
−	можливість створювати нові камбузи в системі;
−	видалення акаунта користувачів та адміністраторів;
−	можливість додавання дверей в камбуз;
−	зміна необхідних прав доступу до дверей;
в)	Mobile застосунок 
В рамках первинного випуску усі користувачі мають один і той же функціонал. 
Для всіх користувачів: 
−	увійти в систему. 
−	налаштовувати профіль та особисті дані. 
−	зробити запит до відкриття дверей.
г)	IoT застосунок
Для всіх користувачів: 
−	отримання та обробка запиту з backend-у на відкриття дверей;
−	відправка даних про успішність відкриття дверей на backend;


1.3.2 Рамки наступних випусків


Деякі основні функції будуть відкладені на наступні випуски програмної системи «eLock», з метою поетапної реалізації та забезпечення стабільності та якості продукту:
	Модуль відстеження активності користувачів: У наступних випусках планується реалізація функціоналу, який дозволить відстежувати та аналізувати активність користувачів в системі для покращення безпеки та ефективності управління.
	Розширений функціонал адміністрування камбузів: Планується додавання нових можливостей для адміністраторів, таких як автоматизоване створення звітів, розширені можливості налаштування прав доступу та управління даними.
	Розширений функціонал мобільного застосунку: У наступних випусках будуть додані нові функції для користувачів мобільного застосунку, такі як можливість керування правами доступу, перегляд статистики та звітів, а також можливість сповіщення про події на камбузі.
	Розширений функціонал IoT застосунку: Планується додати нові можливості до IoT застосунку, які покращать процес взаємодії з фізичними пристроями та забезпечать більшу гнучкість управління доступом.


1.3.3 Обмеження та винятки


Попри широкий функціонал, програмна система «eLock» матиме деякі обмеження та винятки:
	Фізичні обмеження доступу: Система не буде здатна контролювати фізичний доступ до приміщень у разі відсутності встановленого обладнання для цього.
	Функціональні обмеження мобільного застосунку: У першому випуску не буде доступний розширений функціонал мобільного застосунку, такий як керування правами доступу або перегляд статистики.
	Інтеграція зі сторонніми системами: Перші випуски системи можуть мати обмежені можливості інтеграції з іншими інформаційними системами на камбузі.
	Обмеження в конфігуруванні прав доступу: У першому випуску можуть бути обмежені можливості налаштування детальних прав доступу для користувачів і адміністраторів.
	Залежності від обладнання: успіх інтеграції IoT залежить від наявності та сумісності відповідного обладнання.
Ці обмеження та виключення необхідні для забезпечення цілеспрямованого, практичного та ефективного рішення, забезпечуючи при цьому чітке розуміння меж системи.
 
1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Керівництво університету	Покращення безпеки на камбузі; Ефективне управління доступом	Позитивне, бачать в системі можливість забезпечити безпеку та ефективність управління ресурсами камбузу	Забезпечення безпеки студентів та персоналу; Зручне та ефективне керування доступом до приміщень	Фінансові обмеження: не більше 0.05 млн. доларів
Адміністратори камбузу	Підвищення ефективності управління доступом; Спрощення процесів адміністрування	Позитивне, очікують спрощення та автоматизацію рутинних адміністративних процесів	Можливість налаштовувати права доступу; Швидке реагування на потенційні проблеми безпеки; Оптимізація робочих процесів	Потреба в навчанні персоналу
Студенти та персонал камбузу	Зручний та безпечний доступ до приміщень	Позитивне, очікують покращення у зручності та безпеці використання системи	Швидкий та безпечний доступ до приміщень; Простота використання мобільного застосунку	Можливі обмеження використання системи через технічні або процедурні обмеження

 
1.4.2 Пріоритети проєкту


Таблиця 2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План	випуск 1.0 стане доступним до 10.05.2024 
випуск 1.1 – до 10.06.2024		
Функції	70%-80% функцій із високим пріоритетом мають бути включені до випуску 1.0		70% - 80%  функцій із 
високим пріоритетом 
мають бути  включені до 
випуску 1.0
Якість	Система не має критичних помилок, які повністю руйнують її працездатність		Система не має критичних помилок, які повністю руйнують її працездатність.
Команда		Максимальний розмір команд: 1	
Бюджет			Вкластись у встановлений грошовий ліміт

 
1.4.3 Робоче середовище


Система «eLock» буде використовуватися в університетському середовищі, де основні користувачі – студенти, викладачі та адміністратори – знаходяться у зближеному географічному положенні. Більшість користувачів будуть працювати в одному часовому поясі.
Користувачі звертатимуться до системи протягом робочих годин, які відповідають режиму роботи університету. Деякі доступи до системи можуть бути необхідними під час позаробочого часу для екстрених ситуацій або подій.
Дані будуть збиратися та використовуватися в централізованому університетському середовищі. Відстань між різними точками збирання та використання даних буде незначною.
Максимальний час відповіді для доступу до даних, які можуть зберігатися віддалено, буде встановлений на рівні, що забезпечує задовільну продуктивність користувачів.
Постійний доступ до системи важливий для нормального функціонування університетських процесів. Відсутність доступу може вплинути на навчальний процес та адміністративні функції університету.
Система повинна мати високий рівень безпеки доступу та захисту даних, оскільки вона буде обробляти конфіденційну інформацію про студентів, персонал та інші чутливі дані.
Система включає в себе чотири ключові компоненти: backend, frontend, IoT та мобільний додаток. Планується будувати серверну частину з використанням Java, Spring Boot та PostgreSQL, тому необхідно забезпечити серверну частину всім необхідним обладнанням для роботи з цими технологіями та можливість резервного копіювання бази даних. Усі запити до сервера повинні бути захищені та передаватись за допомогою протоколу HTTPS.
Frontend буде розроблено використовуючи template generator Thymeleaf та бібліотекою HTMX, що об’єднує переваги CSR (Client Side Rendering) та SSR (Server Side Rendering).
Оскільки мобільні операційні системи швидко розвиваються і деякі функції можуть втратити підтримку, для впровадження всіх запланованих функцій мобільного додатка використовувати операційну систему Android 9 вважається мінімально допустимою. Розроблення додатку буде проходити за допомогою мови програмування Java у середовищі Android Studio.
 
2 ПОСТАНОВКА ЗАДАЧІ


На основі попереднього аналізу предметної області, метою курсової роботи стало розроблення програмної системи для автоматизації контролю доступу студентів та персоналу в камбузах.
За допомогою застосунку адміністратори університетів повинні мати можливість створювати камбузи, додавати в них зони та з’єднувати їх дверима. Також важливо додати студентів, права доступу до дверей та групи із доступами, аби можна було надавати певну кількість доступів студенту одночасно. Головною відмінністю системи є можливість пошуку шляху студенту від однієї зони до іншої враховуючи права доступу до дверей та групи доступу, що є у студента.
Головний адміністратор має можливість керувати акаунтами всіх адміністраторів системи та створювати нові. Головний адміністратор може видалити користувача або змінити його пароль та інші дані акаунту.
Студенти матимуть застосунок в телефоні, який буде сканувати QR коди на апаратах на дверях (IOT пристрій) та надавати доступ або відмовляти в ньому.
Також важливим буде можливість створити копію бази даних, аби не втратити все випадково.
 
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


При проєктуванні бази даних було розроблено ЄР діаграму (див. рис. 3.1). В неї входить 10 таблиць, а саме: акаунти адміністраторів, камбузи, зони в камбузах, двері між зонами, рівні доступів, групи доступів, студенти, таблиця відношень доступів до дверей, таблиця відношень груп доступів та доступів та таблиця відношень студентів до груп доступів.
 
Рисунок 3.1 – ER-діаграма бази даних

Опишемо кожну таблицю окремо. Таблиці «user_account» та «student» мають ключові поля «id», «first_name», «last_name», «email», та допоміжні поля «created_at», «updated_at», «creadet_by», «updated_by», «version». Таблиця «campus» має ключові поля «id», «name», «location» та допоміжні поля. Таблиця «area» має ключові поля «id», «name», «campus_id» та допоміжні поля. Таблиця «door» має ключові поля «id», «name», «area_from_id», «area_to_id» та допоміжні поля. Таблиці «permission» та «groups» мають ключові поля «id», «name» та допоміжні поля. Також є 3 допоміжні таблиці «door_permission», «groups_permission» та «student_groups» із ключовими полями «door_id», «permission_id», та «group_id», «permission_id», та «student_id», «group_id» відповідно.
Також є зв’язки між таблицями. Таблиця «user_account» має зв’язки з усіма ключовими таблицями через поле «email» та «created_by». Таблиця «campus» має зв’язок один до багатьох із таблицею «area». Таблиця «area» має 2 зв’язки один до багатьох із таблицею «door». Таблиця «door» має зв’язок багато до багатьох із таблицею «permission» за допомогою двох зв’язків один до багатьох із таблицею «door_permission». Таблиця «groups» має зв’язок багато до багатьох із таблицею «permission» через зв’язки один до багатьох через допоміжну таблицю «groups_permission» та зв’язок багато до багатьох із таблицею «student» через допоміжну таблицю «student_groups».
Всі ключові таблиці мають поле «version» для реалізації «Optimistic Lock». Це потрібно, щоб 2 різних транзакції одночасно не могли змінити одні записи у БД.

 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Серверна частина системи «eLock» реалізована з використанням сучасних технологій та фреймворків, що забезпечують високу продуктивність, безпеку та масштабованість, також була використана багатошарова архітектура з використанням патерну проєктування «Facade». Основні компоненти та технології, що використовуються в проекті, включають Java 22, Spring Boot [1], Hibernate, PostgreSQL [2], а також різні бібліотеки для безпеки та документування API.
Spring Boot використовується як основний фреймворк для створення серверної частини. Spring Boot Starter Data JPA використовується для роботи з базою даних за допомогою ORM Hibernate. Spring Boot Starter Security використовується для налаштування безпеки додатку. Spring Boot Starter OAuth2 Client використовується для інтеграції з OAuth2 сервером автентифікації Keycloak [4]. Spring Boot Starter Validation використовується для валідації даних. Spring Boot Starter Web використовується для створення RESTful веб-сервісів. 
PostgreSQL використовується, як основна реляційна база даних. Liquibase використовується для управління змінами в БД, що дозволяє автоматизувати міграцію схем БД. MapStruct використовується для мапінгу даних між різними об’єктами DTO (Data Transfer Object) та Entity. Swagger/OpenAPI використовується для документування RESTful API. 
Lombok [10] використовується для зменшення кількості шаблонного коду за рахунок автоматичної генерації геттерів, сетерів, конструкторів тощо. Для запуску БД та Keycloak використовується Docker [3] та відповідний docker-compose файл.
За допомогою діаграми прецедентів було виявлено функціональні потреби та взаємодію користувачів із системою (див. рис. 4.1).
 
Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи

На рисунку 4.2 ілюстровано діаграму розгортання системи. На ній показано основні 5 компонентів системи їх зв’язки між собою. Реляційна база даних PostgreSQL, яка використовується для зберігання всіх даних про користувачів, групи, дозволи, двері, камбузи та зони. БД взаємодіє з веб-сервером надаючи відповіді на запити до неї. Серверна частина системи, реалізована на Java з використанням Spring Boot. Відповідає за обробку всіх запитів від клієнтів (Frontend, Android додаток) та IoT пристроїв та надсилає запити до БД. Веб-інтерфейс системи, реалізований за допомогою Thymeleaf та HTMX. Надає адміністраторам можливість взаємодіяти з системою через браузер.
 
Рисунок 4.2 – Діаграма розгортання
Мобільний додаток на Android дає студентам можливість взаємодіяти з сервером для пошуку найкоротшого шляху в камбузі та перевірки доступу до конкретних дверей. IoT контролює доступ до дверей. Працює на спеціальному мікро програмному забезпеченні, перевіряє чи має студент доступ до певної двері взаємодіючі з веб-сервером.
Компоненти системи представлені на діаграмі (див. рис. 4.3).
Також було реалізовано скрипт для зберігання бази даних у файл. Його можна побачити у додатку Б разом з іншими частинами коду системи.
 
Рисунок 4.3 – Діаграма компонентів для системи «eLock»


4.2 Архітектура IoT частини


Архітектура IoT частини системи «eLock» складається з пристроїв, які забезпечують контроль доступу до різних зон університетського камбузу. Основні компоненти IoT частини включають мікроконтролер ESP32 [7], сервомотор, LCD-дисплей та мембранну клавіатуру. Ця частина системи відповідає за перевірку доступу користувачів і відкриття дверей у разі підтвердження дозволу (див. рис. 4.4).
 
Рисунок 4.4 – Діаграма прецедентів IoT частини

Мікроконтролер ESP32 виконує основну обробку даних, здійснює підключення до Wi-Fi для комунікації із сервером, та контролює інші компоненти системи. Сервомотор відповідає за фізичне відкриття та закриття дверей і підключений до ESP32 через пін PWM (пін 15). LCD-дисплей використовується для виведення інформації про стан системи та підключений до ESP32 через I2C інтерфейс (SDA - пін 21, SCL - пін 22). Мембранна клавіатура використовується для введення даних користувачами і підключена до ESP32 через цифрові піни (R1-R4: піни 23, 19, 18, 5; C1-C4: піни 17, 16, 4, 2).
Основні компоненти IoT частини системи «eLock» і їхні з'єднання представлені на діаграмі компонентів. Діаграма побудови пристрою (див. рис. 4.5) показує наступні підключення: сервомотор (GND -> ESP32 GND, V+ -> ESP32 5V, PWM -> ESP32 пін 15), LCD (GND -> ESP32 GND, VCC -> ESP32 5V, SDA -> ESP32 пін 21, SCL -> ESP32 пін 22), мембранна клавіатура (R1 -> ESP32 пін 23, R2 -> ESP32 пін 19, R3 -> ESP32 пін 18, R4 -> ESP32 пін 5, C1 -> ESP32 пін 17, C2 -> ESP32 пін 16, C3 -> ESP32 пін 4, C4 -> ESP32 пін 2).
 
Рисунок 4.5 – Діаграма побудови IoT пристрою

Для розробки програмної частини IoT використовувалися наступні бібліотеки: ESP32Servo для керування сервомотором, LiquidCrystal I2C [8] для роботи з LCD-дисплеєм через I2C інтерфейс, Keypad для роботи з мембранною клавіатурою, Password для обробки паролів, введених через клавіатуру, HttpClient для здійснення HTTP-запитів до сервера, та ssd1306 для роботи з OLED дисплеєм (хоча він не використовується в даному проєкті). Детальний перелік використаних бібліотек наведено у файлі libraries.txt та на діаграмі пакетів (див. рис. 4.6).
 
Рисунок 4.6 – Діаграма пакетів IoT пристрою

Для розробки програмної частини IoT пристрою було обрано середовище Wokwi.com [9], яке дозволяє симулювати роботу пристроїв на базі мікроконтролера ESP32. Основний код системи знаходиться у файлі sketch.ino. Система взаємодіє із серверною частиною через HTTP-запити, отримуючи дозволи на відкриття дверей та іншу необхідну інформацію. Після успішної авторизації користувача, мікроконтролер подає сигнал на сервомотор для відкриття дверей та оновлює інформацію на LCD-дисплеї (див. рис. 4.7).
 
Рисунок 4.7 – Діаграми взаємодії IoT системи

Архітектура IoT частини системи «eLock» забезпечує надійну та ефективну автоматизацію доступу в університетських камбузах. Використання сучасних мікроконтролерів та сенсорів дозволяє створити зручну та безпечну систему контролю доступу.
Приклад коду IoT частини застосунку можна побачити у додатку Б.11.


4.3 Архітектура клієнтської частини


Користуватись клієнтською частиною можуть дві ролі – це адміністратор та головний адміністратор.
Основні можливості та потреби головного адміністратора – це створювати звичайних адміністраторів в системі та керувати їх даними в адмін панелі «Keycloak». Вони можуть переглянути наявних адміністраторів, створити нового, редагувати особисті дані створених адміністраторів, видаляти адміністраторів із системи та завершувати сесії адміністраторів.
Основні потреби та можливості адміністраторів – це можливість перегляду, редагування, створення та видалення камбузів у системі; можливість перегляду, створення, редагування та видалення зон в камбузі; можливість перегляду, створення, редагування та видалення дверей у камбузі для з’єднання зон між собою; можливість перегляду, створення, редагування та видалення доступів; можливість перегляду, створення, редагування та видалення груп доступів; можливість створення та видалення зв’язків між доступами та групами доступів; можливість створення та видалення зв’язків між доступами та дверима; можливість перегляду, створення, редагування та видалення студентів; можливість створення та видалення зв’язків між студентами та їх групами доступів.
Взаємодію ролей головного адміністратора та адміністраторів із системою показано за допомогою діаграми прецедентів (див. рис. 4.8).
 
Рисунок 4.8 – Діаграма прецедентів для клієнтської частини системи «eLock»
Із цього виходить, що завдяки діаграмі прецедентів визначились функціональні потреби та взаємодія головного адміністратора та адміністраторів із системою.
Для написання клієнтської частини було використано фреймворк HTMX [5] та шаблонізатор «Thymeleaf» [6]. Такий вибір обумовлений бажанням створити систему, яка поєднує в собі SSR (Server Side Rendering) та CSR(Client Side Rendering). В системі за допомогою HTMX програма робить запити до серверу, який виконує певну бізнес логіку та повертає html код в якості відповіді, яким HTMX замінює певну частину сторінки, що дозволяє користуватись шаблонізатором без необхідності перезавантажувати сторінку на кожному запиті.
При реалізації елементів інтерфейсу використовувалась бібліотека «Bootstrap», яка надає заздалегідь створені стилі для швидкого створення візуально приємного веб додатку.
Для навігації по сайту використовувалась бібліотека Spring MVC та анотація «@Controller», яка всередині використовує Thymeleaf, як View Resolver, що надає можливість конвертувати дані із «моделі» у response у вигляді html коду, використовуючи дані із запиту, який передається «Dispatcher Servlet-ом» у потрібний метод потрібного контролеру методом інтерфейсу «HandlerMapping».
Для виконання запитів до серверу використовуються можливості бібліотеки HTMX, а саме атрибути hx-post, hx-get, hx-put, hx-delete разом із атрибутом hx-target та hx-swap, які визначають який запит зробити та яким чином замінити елемент із певним id на відповідь сервера.
Код розгортався на сервері Tomcat та використовував Spring Dev Tools для автоматичного оновлення змін у реальному часі.
Також було розроблено діаграму пакетів, на якій зображений абстрактний принцип роботи клієнтської системи (див. рис. 4.9).
 
Рисунок 4.9 – Діаграма пакетів для клієнтської частини системи «eLock»
Архітектурно система представлена певною кількістю тек, які функціонально розділяють систему, в певній мірі це можна назвати vertical slicing архітектурою. Є тека «fragments», де зберігаються фрагменти, які неодноразово використовуються іншими фрагментами або сторінками. Головний файл index.html використовує фрагменти headFragment та headerFragment для підключення необхідних ресурсів, таких як Bootsstrap та HTMX та для відображення heard-у сайту. Для того, аби зрозуміти чи користувач авторизований використовується Spring Security, а саме атрибут «sec:authorize».
Також для кожної таблиці (feature) є своя тека (наприклад, є теки campus, area, door, тощо…). В них зберігається index.html файл, який імпортує фрагменти із відповідної теки в теці «fragments», наприклад «fragments/campus/campus.html», «fragments/campus/campuses.html», «fragments/campus/campusForm.html». 
Більш детальна візуалізація архітектури системи показана на ілюстрації діаграми компонентів (див. рис. 4.10).
 
Рисунок 4.10 – Діаграма компонентів для клієнтської частини системи «eLock»
Взаємодія головного адміністратора починається із входу до admin панелі «Keycloak». В цій панелі головний адміністратор може створювати акаунти звичайним адміністраторам, може переглядати наявних адміністраторі, може видалити акаунт адміністратора або змінити особисті дані адміністратора.
Адміністратор починає взаємодіяти із системою з авторизації за допомогою identity provider-а «Keycloak». Після цього у нього є можливість перейти до сторінки з камбузами та подивитись, створити, редагувати чи видалити камбуз створений цим адміністратором. Є можливість зайти всередину камбуза, де можна створити, подивитись, змінити та видалити «area». В кожну зону також можна зайти та побачити, створити, редагувати та видалити двері до іншої зони. Також адміністратори можуть створювати, переглядати, редагувати та видаляти доступи, групи доступів та студентів. Вони можуть поєднувати доступи із групами доступів та дверима, а також поєднувати студентів з групами доступів. Також адміністратори можуть перевірити чи може певний студент відкрити певні двері та розробити шлях між певними зонами в одному камбузі. 
Більш детальна візуалізація взаємодія адміністраторів із клієнтською частиною представлена на діаграмі взаємодії (див. рис. 4.11). 
 
Рисунок 4.11 – Діаграма взаємодії для клієнтської частини системи «eLock»
Частини коду клієнтської частини представлені у додатку В. 
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


Програмна система «eLock» розроблена для автоматизації доступу студентів та персоналу в університетських камбузах. Її запуск може бути здійснений з одного репозиторію, який містить як бекенд, так і фронтенд компоненти, з використанням Maven як основного інструменту для управління проєктом та його залежностями.
Далі треба завантажити Docker Desktop, щоб завантажити та скористуватись базою даних PostgreSQL та identity provider Keycloak. Щоб запустити всі додаткові сервіси необхідно написати команду «docker-compose up».
Далі необхідно запустити програмний код, що можна зробити використовуючи IDE IntelliJ IDEA, який за допомогою Maven (mvn чи .\mvnw spring-boot:run) запускає проєкт. Для запуску із IDE необхідно відкрити проєкт у папці із pom.xml файлом та натиснути кнопку «Run Application».
Щоб запустити IoT частину проєкту, треба зайти на онлайн платформу «Wokwi.com» та створити проєкт з файлами із папки Task3 у репозиторії на GitHub. Також треба натиснути кнопку «Start the simulation».


5.2 Призначення і логічна структура


Функції, які виконує програма «eLock», можна розділити на декілька основних модулів, а саме:
	авторизація та аутентифікація;
	керування камбузами;
	управління користувачами;
	управління доступами;
	пошук шляхів та перевірка доступу;
Модуль «Авторизація та аутентифікація» містить у собі функції для входу в систему та управління сесіями користувачів. Він забезпечує:
	вхід до системи з використанням облікових даних (логін та пароль);
	використання сервісу Keycloak для управління автентифікацією та авторизацією;
	управління сесіями користувачів, включаючи можливість виходу з системи.
Модуль «Керування камбузами» дозволяє адміністраторам створювати та редагувати інформацію про камбузи, а також управляти зонами та дверима в межах камбузів. Він забезпечує:
	створення нових камбузів та додавання їх до системи;
	редагування інформації про камбузи (назва, розташування);
	створення, редагування та видалення зон в камбузах;
	створення, редагування та видалення дверей, що з'єднують зони.
Модуль «Управління користувачами» є адміністраторським і містить функції для керування обліковими записами користувачів. Він забезпечує:
	створення та редагування облікових записів адміністраторів та студентів;
	призначення ролей та прав доступу користувачам;
	видалення облікових записів користувачів з системи.
Модуль «Управління доступами» дозволяє адміністраторам визначати та керувати правами доступу до різних зон та дверей в камбузах. Він забезпечує:
	створення та редагування доступів до дверей;
	створення та редагування груп доступів;
	призначення доступів користувачам або групам користувачів;
	перевірка та управління правами доступу для користувачів.
Модуль «Пошук шляхів та перевірка доступу» забезпечує функції для пошуку оптимальних маршрутів між зонами в камбузі з урахуванням прав доступу користувачів. Він забезпечує:
	пошук шляху від однієї зони до іншої з врахуванням доступу до дверей;
	перевірка прав доступу користувача до конкретних дверей;
	інтеграція з IoT пристроями для перевірки доступу та відкриття дверей.
Кожен з цих модулів взаємодіє між собою, утворюючи цілісну систему для автоматизації доступу студентів та персоналу в університетських камбузах, забезпечуючи високу ефективність, безпеку та зручність користування.


5.3 Опис програмної реалізації


При відкритті будь-якої сторінки вперше нас перенаправить на сторінку із авторизацією для адміністраторів в адмін панелі Keycloak (див. рис. 5.1).
 
Рисунок 5.1 – Сторінка авторизації в адмін панелі Keycloak
Після успішної авторизації можна перейти на сторінку з камбузами та переглянути, створити, відредагувати та видалити камбуз (див. рис. 5.2).
 
Рисунок 5.2 – Сторінка з камбузами
Після цього можна перейти до конкретного камбузу, щоб переглянути, створити, відредагувати та видалити наявні зони в камбузі (див. рис. 5.3). 
 
Рисунок 5.3 – Сторінка із зонами камбузу
Якщо відкрити зону – можна переглянути, створити, відредагувати та видалити двері, а також додати чи видалити до дверей певні доступи (див. рис. 5.4).
 
Рисунок 5.4 – Сторінка із дверима та доступами до них
Переглянути , додати, змінити та видалити доступ можна на сторінці із доступами (див. рис. 5.5). Також ці доступи можна поєднати із дверима та групами доступів.
 
Рисунок 5.5 – Сторінка з доступами
На сторінці із групами можна створити, переглянути, відредагувати та видалити групи доступів для студентів та додати певні доступи до груп доступів (див. рис. 5.6).
 
Рисунок 5.6 – Сторінка з групами доступів
На сторінці з студентами можна переглянути, створити, відредагувати акаунт студента та додати чи видалити йому певні групи доступів (див. рис. 5.7).
 
Рисунок 5.7 – Сторінка з студентами
На сторінці з логікою можна перевірити чи певний студент має доступ до певної двері (див. рис. 5.8).
 
Рисунок 5.8 – Сторінка з логікою на перевірку доступу до дверей

Також на сторінці з логікою можна знайти шлях від однієї зони до іншої або отримати відповідь, що студент не може дістатись до неї (див. рис. 5.9).
 
Рисунок 5.9 – Сторінка з логікою із демонстрацією пошуку шляху

Якщо адміністратор хоче вийти із системи у нього ще раз запитають чи він хоче зробити цю дію (див. рис. 5.10).
 
Рисунок 5.10 – Сторінка із додатковою перевіркою на вихід з акаунту
Також головний адміністратор може керувати акаунтами звичайних адміністраторів через адмін панель в Keycloak (див. рис. 5.11). В ній він може створювати, редагувати, переглядати та видаляти акаунти адміністраторам. Також він може завершувати сесії їм.
 
Рисунок 5.11 – Сторінка Keycloak для головного адміністратора
Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою «eLock».
Запис результатів функціонального тестування можна подивитись за посиланням: https://www.youtube.com/watch?v=9LqAjJvG0uA
 
ВИСНОВКИ


У процесі роботи розроблено програмну систему «eLock» для автоматизації доступу студентів та персоналу в університетських камбузах. Проведено аналіз предметної області, спроектовано базу даних, розроблено архітектуру серверної, клієнтської та IoT частин системи.
Система реалізована з використанням Java 17, Spring Boot, PostgreSQL, HTMX, Thymeleaf та мікроконтролера ESP32. Вона забезпечує централізоване керування адміністраторами, камбузами, зонами, дверима, студентами, доступами та групами доступів. «eLock» інтегрується з IoT пристроями для надання доступу, дозволяє шукати шляхи між зонами, моніторити та аналізувати події в системі.
Система підвищує ефективність управління доступом, забезпечує високий рівень безпеки та зручності, адаптуючись до потреб сучасних навчальних закладів, створюючи безпечне та зручне середовище.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Spring Boot documentation. URL: https://spring.io/projects/spring-boot (дата звернення 20.07.2024).
2.	PostgreSQL documentation. URL: https://www.postgresql.org/docs/ (дата звернення 20.07.2024).
3.	Docker documentation. URL: https://docs.docker.com/ (дата звернення 20.07.2024).
4.	Keycloak documentation. URL: https://www.keycloak.org/documentation (дата звернення 20.07.2024).
5.	HTMX documentation. URL: https://htmx.org/docs/ (дата звернення 20.07.2024).
6.	Thymeleaf documentation. URL: https://www.thymeleaf.org/documents.html (дата звернення 20.07.2024).
7.	ESP32 Servo Library documentation. URL: https://github.com/madhephaestus/ESP32Servo (дата звернення 20.07.2024).
8.	LiquidCrystal I2C Library documentation. URL: https://github.com/johnrickman/LiquidCrystal_I2C (дата звернення 20.07.2024).
9.	Wokwi documentation. URL: https://docs.wokwi.com/ (дата звернення 20.07.2024).
10.	 Lombok documentation. URL: https://projectlombok.org/features/all (дата звернення 20.07.2024). 
ДОДАТОК А 
Результат перевірки на плагіат

 
Рисунок А.1 – Результат перевірки на плагіат
 
ДОДАТОК Б 
Програмний код серверної частини
Б.1 Код файлу StudentFacadeImpl.java із перевіркою доступу до дверей:


1. package ua.clamor1s.eLock.facade.impl;
2. 
3. import lombok.RequiredArgsConstructor;
4. import org.springframework.retry.annotation.Backoff;
5. import org.springframework.retry.annotation.Retryable;
6. import org.springframework.stereotype.Component;
7. import org.springframework.transaction.annotation.Transactional;
8. import ua.clamor1s.eLock.dto.request.StudentGroupRequest;
9. import ua.clamor1s.eLock.dto.request.StudentRequest;
10. import ua.clamor1s.eLock.dto.response.StudentGroupResponse;
11. import ua.clamor1s.eLock.dto.response.StudentResponse;
12. import ua.clamor1s.eLock.entity.Door;
13. import ua.clamor1s.eLock.entity.Group;
14. import ua.clamor1s.eLock.entity.Permission;
15. import ua.clamor1s.eLock.entity.Student;
16. import ua.clamor1s.eLock.facade.StudentFacade;
17. import ua.clamor1s.eLock.service.DoorService;
18. import ua.clamor1s.eLock.service.GroupService;
19. import ua.clamor1s.eLock.service.StudentService;
20. 
21. import java.util.List;
22. import java.util.Set;
23. import java.util.stream.Collectors;
24. 
25. @Component
26. @RequiredArgsConstructor
27. public class StudentFacadeImpl implements StudentFacade {
28. 
29.     private final StudentService studentService;
30.     private final GroupService groupService;
31.     private final DoorService doorService;
32. 
33.     @Transactional(readOnly = true)
34.     @Override
35.     public List<StudentResponse> getAllStudents() {
36.         List<Student> students = studentService.getAllStudents();
37.         return students.stream()
38.                 .map(studentService::convertStudentToStudentResponse)
39.                 .collect(Collectors.toList());
40.     }
41. 
42.     @Transactional(readOnly = true)
43.     @Override
44.     public List<StudentGroupResponse> getAllStudentGroups() {
45.         List<Student> students = studentService.getAllStudents();
46.         return students.stream()
47.                 .flatMap(student -> studentService.getStudentGroups(student).stream())
48.                 .collect(Collectors.toList());
49.     }
50. 
51.     @Transactional
52.     @Override
53.     public StudentResponse createStudent(StudentRequest studentRequest) {
54.         Student student = studentService.createStudent(studentRequest);
55.         return studentService.convertStudentToStudentResponse(student);
56.     }
57. 
58.     @Transactional
59.     @Override
60.     public StudentResponse updateStudent(Long studentId, StudentRequest studentRequest) {
61.         Student student = studentService.getStudentById(studentId);
62.         student = studentService.updateStudent(student, studentRequest);
63.         return studentService.convertStudentToStudentResponse(student);
64.     }
65. 
66.     @Transactional
67.     @Override
68.     public StudentResponse deleteStudent(Long studentId) {
69.         Student student = studentService.getStudentById(studentId);
70.         StudentResponse response = studentService.convertStudentToStudentResponse(student);
71.         studentService.deleteStudent(student);
72.         return response;
73.     }
74. 
75.     @Transactional
76.     @Override
77.     public StudentGroupResponse addGroup(StudentGroupRequest studentGroupRequest) {
78.         Student student = studentService.getStudentById(studentGroupRequest.getStudentId());
79.         Group group = groupService.getGroupById(studentGroupRequest.getGroupId());
80.         return studentService.addGroup(student, group);
81.     }
82. 
83.     @Transactional
84.     @Override
85.     public StudentGroupResponse removeGroup(Long studentId, Long groupId) {
86.         Student student = studentService.getStudentById(studentId);
87.         Group group = groupService.getGroupById(groupId);
88.         return studentService.removeGroup(student, group);
89.     }
90. 
91.     @Transactional(readOnly = true)
92.     @Retryable(retryFor = Exception.class, maxAttempts = 5, backoff = @Backoff(delay = 300))
93.     @Override
94.     public boolean isDoorAvailable(Long doorId, Long studentId) {
95.         Student student = studentService.getStudentById(studentId);
96.         Door door = doorService.getDoorById(doorId);
97. 
98.         Set<Permission> doorPermissions = door.getPermissions();
99.         Set<Permission> studentPermissions = student.getGroups().stream()
100.                 .flatMap(group -> group.getPermissions().stream())
101.                 .collect(Collectors.toSet());
102.         return studentPermissions.stream().anyMatch(doorPermissions::contains);
103.     }
104. 
105.     @Transactional(readOnly = true)
106.     @Override
107.     public StudentResponse getById(Long studentId) {
108.         Student student = studentService.getStudentById(studentId);
109.         return studentService.convertStudentToStudentResponse(student);
110.     }
111. }
112.


Б.2 Код для пошуку шляху між зонами:


1. package ua.clamor1s.eLock.service.impl;
2. 
3. import lombok.RequiredArgsConstructor;
4. import org.springframework.stereotype.Service;
5. import org.springframework.transaction.annotation.Transactional;
6. import ua.clamor1s.eLock.dto.request.DoorRequest;
7. import ua.clamor1s.eLock.dto.response.AreaResponse;
8. import ua.clamor1s.eLock.dto.response.DoorPermissionResponse;
9. import ua.clamor1s.eLock.dto.response.DoorResponse;
10. import ua.clamor1s.eLock.entity.Area;
11. import ua.clamor1s.eLock.entity.Door;
12. import ua.clamor1s.eLock.entity.Permission;
13. import ua.clamor1s.eLock.entity.User;
14. import ua.clamor1s.eLock.mapper.AreaMapper;
15. import ua.clamor1s.eLock.mapper.DoorMapper;
16. import ua.clamor1s.eLock.repository.DoorRepository;
17. import ua.clamor1s.eLock.service.DoorService;
18. import ua.clamor1s.eLock.utils.AuthUtils;
19. 
20. import java.util.ArrayDeque;
21. import java.util.ArrayList;
22. import java.util.Collections;
23. import java.util.Deque;
24. import java.util.HashMap;
25. import java.util.List;
26. import java.util.Map;
27. import java.util.Objects;
28. import java.util.Set;
29. import java.util.stream.Collectors;
30. 
31. @Service
32. @RequiredArgsConstructor
33. public class DoorServiceImpl implements DoorService {
34. 
35.     private final AuthUtils authUtils;
36.     private final DoorMapper doorMapper;
37.     private final DoorRepository doorRepository;
38.     private final AreaMapper areaMapper;
39. 
40. 
41.     @Override
42.     @Transactional(readOnly = true)
43.     public List<Door> getFromDoorsByArea(Area area) {
44.         authUtils.validateUser(area.getCreatedBy());
45.         return area.getDoorsFrom();
46.     }
47. 
48.     @Override
49.     @Transactional(readOnly = true)
50.     public List<Door> getToDoorsByArea(Area area) {
51.         authUtils.validateUser(area.getCreatedBy());
52.         return area.getDoorsTo();
53.     }
54. 
55.     @Override
56.     @Transactional
57.     public Door createDoor(Area from, Area to, DoorRequest doorRequest) {
58.         authUtils.validateUser(from.getCreatedBy());
59.         authUtils.validateUser(to.getCreatedBy());
60.         User user = authUtils.getCurrentUser().orElseThrow(() -> new RuntimeException());
61.         Door door = doorMapper.doorRequestToDoorEntity(doorRequest, from, to);
62.         door.setCreatedBy(user.getEmail());
63.         return doorRepository.save(door);
64.     }
65. 
66.     @Override
67.     @Transactional(readOnly = true)
68.     public Door getDoorById(Long doorId) {
69.         return doorRepository.findById(doorId).orElseThrow(() -> new RuntimeException());
70.     }
71. 
72.     @Override
73.     @Transactional
74.     public Door updateDoor(Door door, DoorRequest doorRequest, Area from, Area to) {
75.         door.setFrom(from);
76.         door.setTo(to);
77.         doorMapper.updateDoorByDoorRequest(door, doorRequest);
78.         return doorRepository.save(door);
79.     }
80. 
81.     @Override
82.     @Transactional
83.     public void deleteDoor(Door door) {
84.         doorRepository.delete(door);
85.     }
86. 
87.     @Override
88.     @Transactional
89.     public void addPermission(Door door, Permission permission) {
90.         door.addPermission(permission);
91.         doorRepository.save(door);
92.     }
93. 
94.     @Override
95.     @Transactional(readOnly = true)
96.     public List<DoorPermissionResponse> getDoorPermissions(Door door) {
97.         Set<Permission> permissions = door.getPermissions();
98.         return permissions.stream()
99.                 .map(permission -> new DoorPermissionResponse(door.getId(), permission.getId()))
100.                 .toList();
101.     }
102. 
103.     @Transactional
104.     @Override
105.     public void deleteDoorPermission(Door door, Permission permission) {
106.         door.removePermission(permission);
107.         doorRepository.save(door);
108.     }
109. 
110.     @Transactional(readOnly = true)
111.     @Override
112.     public List<AreaResponse> getDoorsPath(Area areaFrom, Area areaTo, Set<Permission> studentPermissions) {
113.         if (areaFrom.equals(areaTo)) {
114.             return List.of(areaMapper.mapAreaToAreaResponse(areaFrom));
115.         }
116.         Deque<Area> queue = new ArrayDeque<>();
117.         Map<Area, Area> from = new HashMap<>();
118.         queue.add(areaFrom);
119.         while (!queue.isEmpty()) {
120.             Area area = queue.poll();
121.             area.getDoorsFrom().stream()
122.                     .filter(door -> door.getPermissions().stream()
123.                             .anyMatch(studentPermissions::contains))
124.                     .map(Door::getTo)
125.                     .forEach(areaIterateTo -> {
126.                         Area areaIterateToFrom = from.getOrDefault(areaIterateTo, null);
127.                         boolean cont = false;
128.                         if (Objects.nonNull(areaIterateToFrom)) {
129.                             cont = true;
130.                         }
131.                         if (!cont) {
132.                             from.put(areaIterateTo, area);
133.                             queue.add(areaIterateTo);
134.                         }
135.                     });
136.         }
137.         if (Objects.isNull(from.getOrDefault(areaTo, null))) {
138.             return List.of();
139.         }
140.         List<Area> areas = new ArrayList<>();
141.         Area lastArea = areaTo;
142.         do {
143.             areas.add(lastArea);
144.             lastArea = from.get(lastArea);
145.             if (Objects.isNull(lastArea)) {
146.                 return List.of();
147.             }
148.         } while (!lastArea.equals(areaFrom));
149.         areas.add(areaFrom);
150. 
151.         List<AreaResponse> result = areas.stream()
152.                 .map(areaMapper::mapAreaToAreaResponse)
153.                 .collect(Collectors.toList());
154.         Collections.reverse(result);
155.         return result;
156.     }
157. 
158.     @Override
159.     public DoorResponse convertDoorToDoorResponse(Door door) {
160.         return doorMapper.convertDoorToDoorResponse(door);
161.     }
162. }
163.


Б.3 Код docker-compose.yml файлу:


1. version: "3.9"
2. 
3. services:
4.   postgres-e-lock:
5.     image: postgres
6.     container_name: e-lock-backend
7.     ports:
8.       - "5433:5432"
9.     environment:
10.       POSTGRES_DB: e-lock-backend
11.       POSTGRES_USER: postgres
12.       POSTGRES_PASSWORD: admin
13.   keycloak_web:
14.     image: quay.io/keycloak/keycloak:23.0.7
15.     container_name: keycloak_web
16.     environment:
17.       KC_HOSTNAME: localhost
18.       KEYCLOAK_ADMIN: admin
19.       KEYCLOAK_ADMIN_PASSWORD: admin
20.     command: "start-dev"
21.     ports:
22.       - 19090:8080
23.


Б.4 Код скрипта для зберігання БД:


1. @echo off
2. 
3. REM Set environment variables
4. set CONTAINER_NAME=e-lock-backend
5. set DB_NAME=e-lock-backend
6. set DB_USER=postgres
7. set DB_PASSWORD=admin
8. set BACKUP_DIR=%~dp0backups
9. set BACKUP_FILE=%BACKUP_DIR%\%DB_NAME%_backup_%DATE:~10,4%-%DATE:~4,2%-%DATE:~7,2%.sql
10. 
11. REM Ensure the backup directory has write permissions
12. if not exist %BACKUP_DIR% (
13.     mkdir %BACKUP_DIR%
14.     if %errorlevel% neq 0 (
15.         echo Failed to create backup directory: %BACKUP_DIR%
16.         pause
17.         exit /b 1
18.     )
19. )
20. 
21. REM Check if the backup file already exists and handle it
22. if exist %BACKUP_FILE% (
23.     echo Backup file already exists. Removing the old backup file.
24.     del %BACKUP_FILE%
25.     if %errorlevel% neq 0 (
26.         echo Failed to remove existing backup file: %BACKUP_FILE%
27.         pause
28.         exit /b 1
29.     )
30. )
31. 
32. REM Run the backup command
33. docker exec -e PGPASSWORD=%DB_PASSWORD% %CONTAINER_NAME% pg_dump -U %DB_USER% %DB_NAME% -F c > %BACKUP_FILE%
34. if %errorlevel% neq 0 (
35.     echo Backup command failed
36.     pause
37.     exit /b 1
38. )
39. 
40. REM Check if the backup file was created successfully
41. if exist %BACKUP_FILE% (
42.     echo Backup completed successfully: %BACKUP_FILE%
43. ) else (
44.     echo Backup failed
45.     pause
46.     exit /b 1
47. )
48. 
49. pause


Б.5 Код фрагменту з показом одного студента:


1. <tr th:fragment="studentFragment (student)">
2.   <th scope="row" th:text="${student.id}"></th>
3.   <td>
4.     <label for="studentFirstName"></label>
5.     <input class="form-control"
6.            type="text"
7.            th:value="${student.firstName}" id="studentFirstName" th:name="firstName"/>
8.   </td>
9.   <td>
10.     <label for="studentLastName"></label>
11.     <input class="form-control"
12.            type="text"
13.            th:value="${student.lastName}" id="studentLastName" th:name="lastName"/>
14.   </td>
15.   <td>
16.     <label for="studentEmail"></label>
17.     <input class="form-control"
18.            type="text"
19.            th:value="${student.email}" id="studentEmail" th:name="email"/>
20.   </td>
21.   <td th:text="${student.createdAt}"></td>
22.   <td th:text="${student.updatedAt}"></td>
23.   <td th:text="${student.createdBy}"></td>
24.   <td>
25.     <button type="button" class="btn btn-outline-primary"
26.             th:hx-put="@{/student/{id}(id=${student.id})}"
27.             hx-include="closest tr"
28.             hx-target="#student-list-container"
29.             hx-swap="outerHTML"
30.     >
31.       Update
32.     </button>
33.   </td>
34.   <td>
35.     <button type="button" class="btn btn-danger"
36.             th:hx-delete="@{/student/{id}(id=${student.id})}"
37.             hx-target="#student-list-container"
38.             hx-swap="outerHTML"
39.     >
40.       Delete
41.     </button>
42.   </td>
43. </tr>


Б.6 Код фрагмента форми студента:


1. <div id="student-form-container" th:fragment="studentFormFragment">
2.   <form class="row g-3"
3.         hx-post="/student"
4.         hx-target="#student-list-container"
5.         hx-swap="outerHTML"
6.   >
7.     <div class="col-md-4">
8.       <label for="validationDefault01" class="form-label">First Name</label>
9.       <input type="text" class="form-control" id="validationDefault01" name="firstName" required>
10.     </div>
11.     <div class="col-md-4">
12.       <label for="validationDefault02" class="form-label">Last Name</label>
13.       <input type="text" class="form-control" id="validationDefault02" name="lastName" required>
14.     </div>
15.     <div class="col-md-4">
16.       <label for="validationDefault03" class="form-label">Email</label>
17.       <input type="email" class="form-control" id="validationDefault03" name="email" required>
18.     </div>
19. 
20.     <div class="col-12">
21.       <div class="form-check">
22.         <input class="form-check-input" type="checkbox" value="" id="invalidCheck2" required>
23.         <label class="form-check-label" for="invalidCheck2">
24.           Agree to terms and conditions
25.         </label>
26.       </div>
27.     </div>
28.     <div class="col-12">
29.       <button class="btn btn-primary" type="submit">Add Student</button>
30.     </div>
31.   </form>
32. </div>


Б.7 Код фрагменту показу всіх студентів:


1. <div id="student-list-container" th:fragment="studentsFragment (students)">
2.   <tr th:if="${#lists.isEmpty(students)}">
3.     <td colspan="2"> No Students Available </td>
4.   </tr>
5.   <table class="table">
6.     <thead>
7.     <tr>
8.       <th scope="col">#</th>
9.       <th scope="col">First Name</th>
10.       <th scope="col">Last Name</th>
11.       <th scope="col">Email</th>
12.       <th scope="col">createdAt</th>
13.       <th scope="col">updatedAt</th>
14.       <th scope="col">createdBy</th>
15.       <th scope="col"></th>
16.       <th scope="col"></th>
17.     </tr>
18.     </thead>
19.     <tbody class="table-group-divider" th:each="student : ${students}">
20.       <tr th:replace="~{/fragments/student/student :: studentFragment (${student})}"></tr>
21.     </tbody>
22.   </table>
23. </div>


Б.8 Код сторінки з студентами

1. <!DOCTYPE html>
2. <html xmlns:th="http://www.thymeleaf.org">
3. <head th:replace="~{fragments/head :: headFragment}"></head>
4. <body>
5.   <header th:replace="~{fragments/header :: headerFragment}"></header>
6.   <h1>Welcome to the Student Page</h1>
7.   <br />
8.   <div id="student-list-container" th:insert="~{fragments/student/students :: studentsFragment (${students})}"></div>
9.   <div id="student-form-container" th:insert="~{fragments/student/studentForm :: studentFormFragment}"></div>
10. 
11.   <div id="student-group-form-container" th:insert="~{fragments/student/studentGroupForm :: studentGroupFormFragment(${students}, ${groups})}"></div>
12.   <div id="student-group-list-container" th:insert="~{fragments/student/studentGroups :: studentGroupsFragment(${studentGroups})}"></div>
13. 
14. </body>
15. </html>


Б.9 Код вхідних даних бізнес логіки:


1. <div id="logic-campus-area-door-permission" th:fragment="campusAreaDoorPermission (students, campuses)">
2.   <h4>Is Door available for student?</h4>
3.   <form id="campus-area-form">
4.     <div>
5.       <label for="student">Select Student:</label>
6.       <select id="student" name="student">
7.         <option th:value="-1">Select a Student</option>
8.         <th:block th:each="student : ${students}">
9.           <option th:value="${student.id}" th:text="${student.email}"></option>
10.         </th:block>
11.       </select>
12.     </div>
13.     <div>
14.       <label for="campus">Select Campus:</label>
15.       <select id="campus" name="campus" th:hx-get="@{/logic/area}" hx-target="#area-door-form" hx-include="this">
16.         <option th:value="-1">-- Select a campus --</option>
17.         <th:block th:each="campus : ${campuses}">
18.           <option th:value="${campus.id}" th:text="${campus.name}"></option>
19.         </th:block>
20.       </select>
21.     </div>
22.     <div id="area-door-form"></div>
23.     <div id="door-form"></div>
24.   </form>
25.   <br />
26.   <div id="logic-path" th:insert="~{fragments/logic/logicPath :: logicPath (${students}, ${campuses})}"></div>
27. </div>
28. 
29. <div id="area-door-form" th:fragment="emptyAreaDoorFormFragment"></div>
30. 
31. <div id="area-door-form" th:fragment="areaDoorFormFragment (areas)">
32.   <th:block>
33.     <label for="area">Select Area:</label>
34.     <select id="area" name="area" th:hx-get="@{/logic/door}" hx-target="#door-form" hx-include="this">
35.       <option th:value="-1">Select an Area:</option>
36.       <th:blcok th:each="area : ${areas}">
37.         <option th:value="${area.id}" th:text="${area.name}"></option>
38.       </th:blcok>
39.     </select>
40.   </th:block>
41. </div>
42. 
43. <div id="door-form" th:fragment="emptyDoorFormFragment"></div>
44. 
45. <div id="door-form" th:fragment="doorFormFragment (doors)">
46.   <th:block>
47.     <label for="door">Select Door:</label>
48.     <select id="door" name="door" th:hx-get="@{/logic/door-available}" hx-target="#logic-result" hx-include="#door, #student, #area, #campus"
49.             hx-trigger="change from:(#logic-result), change from:(#door-form), change from:(#student), change from:(#area-door-form), change from:(#campus)">
50.       <option th:value="-1">Select A Door:</option>
51.       <th:block th:each="door : ${doors}">
52.         <option th:value="${door.id}" th:text="${door.name}"></option>
53.       </th:block>
54.     </select>
55.   </th:block>
56. </div>
57. 
58. <div id="logic-result" th:fragment="emptyResult"></div>
59. 
60. <div id="logic-result" th:fragment="resultPermission (available)">
61.   <h3>Result:</h3>
62.   <p th:text="${available}"></p>
63. </div>
64.


Б.10 Код бізнес логіки з пошуком шляху між зонами:


1. <div id="logic-path" th:fragment="logicPath (students, campuses)">
2.   <h4>Logic Path search!</h4>
3.   <form id="campus-area-form-path">
4.     <div>
5.       <label for="student-path">Select Student:</label>
6.       <select id="student-path" name="student">
7.         <option th:value="-1">Select a Student</option>
8.         <th:block th:each="student : ${students}">
9.           <option th:value="${student.id}" th:text="${student.email}"></option>
10.         </th:block>
11.       </select>
12.     </div>
13.     <div>
14.       <label for="campus-path">Select Campus:</label>
15.       <select id="campus-path" name="campus" th:hx-get="@{/logic/area/path}" hx-target="#area-door-form-path" hx-include="this">
16.         <option th:value="-1">-- Select a campus --</option>
17.         <th:block th:each="campus : ${campuses}">
18.           <option th:value="${campus.id}" th:text="${campus.name}"></option>
19.         </th:block>
20.       </select>
21.     </div>
22.     <div id="area-door-form-path"></div>
23. 
24. 
25.   </form>
26. </div>
27. 
28. <div id="area-door-form-path" th:fragment="emptyAreaDoorFormPathFragment"></div>
29. <div id="area-door-form-path" th:fragment="areaDoorFormPathFragment (areas)">
30.     <div id="area-door-form-path-from">
31.     <th:block>
32.       <label for="area-from">Select From Area(From):</label>
33.       <select id="area-from" name="areaFrom">
34.         <option th:value="-1">Select an Area(From):</option>
35.         <th:blcok th:each="area : ${areas}">
36.           <option th:value="${area.id}" th:text="${area.name}"></option>
37.         </th:blcok>
38.       </select>
39.     </th:block>
40.   </div>
41. 
42.   <div id="area-door-form-path-to">
43.     <th:block>
44.       <label for="area-to">Select From Area(To):</label>
45.       <select id="area-to" name="areaTo">
46.         <option th:value="-1">Select an Area(To):</option>
47.         <th:blcok th:each="area : ${areas}">
48.           <option th:value="${area.id}" th:text="${area.name}"></option>
49.         </th:blcok>
50.       </select>
51.     </th:block>
52.   </div>
53. 
54.   <button hx-post="/logic/find-path"
55.           hx-trigger="click"
56.           hx-target="#logic-result"
57.           hx-swap="outerHTML"
58.           hx-include="#student-path, #campus-path, #area-from, #area-to"
59.           type="button" class="btn btn-outline-primary"
60.   >
61.     Find Path
62.   </button>
63. </div>
64. 
65. <div id="logic-result" th:fragment="logicResultPathFragment (result)">
66.   <h5 th:text="${result}"></h5>
67. </div>
Б.11 Програмний код IoT частини:


1. #include <ESP32Servo.h>
2. #include <LiquidCrystal_I2C.h>
3. #include <Keypad.h>
4. 
5. 
6. #include <HTTPClient.h>
7. #include "WiFi.h"
8. 
9. 
10. #define servoPin 15
11. 
12. Servo servo;
13. 
14. LiquidCrystal_I2C lcd(0x27, 16, 2);
15. 
16. const byte ROWS = 4;
17. const byte COLS = 4;
18. 
19. char keys[ROWS][COLS] = {
20.   {'1', '2', '3', 'A'},
21.   {'4', '5', '6', 'B'},
22.   {'7', '8', '9', 'c'},
23.   {'*', '0', '#', 'D'},
24. };
25. byte rowPins[ROWS] = {23, 19, 18, 5};
26. byte colPins[COLS] = {17, 16, 4, 2};
27. 
28. bool isDoorLocked = true;
29. String password = "";
30. 
31. byte maxPasswordLength = 6;
32. byte currentPasswordLength = 0;
33. 
34. String doorId;
35. 
36. Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
37. 
38. void setup() {
39.   Serial.begin(115200);
40. 
41.   Serial.begin(115200);
42.   Serial.println("Enter Door ID: ");
43.   while (!Serial.available()); // Wait for input
44.   doorId = Serial.readStringUntil('\n');
45.   
46.   servo.attach(servoPin);
47.   servo.write(10);
48.   lcd.init();
49.   lcd.backlight();
50.   lcd.setCursor(0, 0);
51.   lcd.print("Door LOCK System");
52.   delay(2000);
53.   lcd.clear();
54. }
55. 
56. void loop() {
57.   lcd.setCursor(3, 0);
58.   isDoorLocked ? lcd.print("DOOR LOCKED") : lcd.print("DOOR OPEN");
59. 
60.   char key = keypad.getKey();
61.   Serial.println(key);
62.   if (key != NO_KEY) {
63.     delay(100);
64. 
65.     if (key == '#') {
66.       resetPassword();
67.     } else if (key == '*') {
68.       isDoorLocked = !isDoorLocked;
69.       isDoorLocked ? doorLocked() : doorOpen();
70.     } else {
71.       processNumberKey(key);
72.     }
73.   }
74. }
75. 
76. void processNumberKey(char key) {
77.   if (currentPasswordLength < maxPasswordLength) {
78.     lcd.setCursor(currentPasswordLength + 5, 1);
79.     lcd.print("*");
80.     password+= key;
81.     currentPasswordLength++;
82.   }
83. }
84. 
85. void doorLocked() {
86.   if (checkAccess(password)) {
87.     servo.write(10);
88.     displayMessage("Password Correct", "LOCKED");
89.   } else {
90.     displayMessage("Wrong Password", "Try Again");
91.   }
92.   resetPassword();
93. }
94. 
95. void doorOpen() {
96.   if (checkAccess(password)) {
97.     servo.write(180);
98.     displayMessage("Password Correct", "UNLOCKED");
99.   } else {
100.     displayMessage("Wrong Password", "Try Again");
101.   }
102.   resetPassword();
103. }
104. 
105. void resetPassword() {
106.   password = "";
107.   currentPasswordLength = 0;
108.   lcd.clear();
109.   lcd.setCursor(0, 0);
110. }
111. 
112. void displayMessage(const char *line1, const char *line2) {
113.   lcd.clear();
114.   lcd.setCursor(0, 0);
115.   lcd.print(line1);
116.   lcd.setCursor(3, 1);
117.   lcd.print(line2);
118.   lcd.clear();
119. }
120. 
121. bool checkAccess(String id) {
122.   String api = "http://localhost:8080/api/v1/student/" + id + "/door/" + doorId + "/available";
123.   
124.   wifiConnect();
125. 
126.   if (WiFi.status() == WL_CONNECTED) {
127.     Serial.println("API: " + api);
128. 
129.     HTTPClient http;
130.     http.begin(api);
131.     http.addHeader("Content-Type", "application/json");
132. 
133.     int httpResponseCode = http.GET();
134. 
135.     if (httpResponseCode > 0) {
136.       String response = http.getString();
137.       Serial.println(httpResponseCode);
138.       Serial.println(response);
139. 
140.       if (response == "true") {
141.         return true;
142.       } else {
143.         return false;
144.       }
145.     } else {
146.       Serial.print("Error on sending POST: ");
147.       Serial.println(httpResponseCode);
148.       return false;
149.     }
150. 
151.     http.end();
152.     
153.   }
154. }
155. 
156. void wifiConnect() {
157.   int n = WiFi.scanNetworks();
158.   Serial.println("Scan done!");
159.   if (n == 0) {
160.     Serial.println("No networks found.");
161.   } else {
162.     Serial.println();
163.     Serial.print(n);
164.     Serial.println(" networks found");
165.     for (int i = 0; i < n; ++i) {
166.       Serial.println(WiFi.SSID(i));
167.       if (WiFi.SSID(i) == "Wokwi-GUEST") {
168.         Serial.begin(9600);
169.         Serial.print("Connecting to WiFi");
170.         WiFi.begin("Wokwi-GUEST", "", 6);
171.         while (WiFi.status() != WL_CONNECTED) {
172.           delay(100);
173.           Serial.print(".");
174.         }
175.         Serial.println(" Connected!");
176.       }
177.       delay(10);
178.     }
179.   }
180.   Serial.println("");
181. }


Б.12 Код діаграми (файл diagram.json) IoT частини системи


1. {
2.   "version": 1,
3.   "author": "YP",
4.   "editor": "wokwi",
5.   "parts": [
6.     { "type": "board-esp32-devkit-c-v4", "id": "esp", "top": -9.6, "left": -129.56, "attrs": {} },
7.     { "type": "wokwi-servo", "id": "servo1", "top": -251.6, "left": -115.2, "attrs": {} },
8.     {
9.       "type": "wokwi-lcd1602",
10.       "id": "lcd1",
11.       "top": -166.4,
12.       "left": 82.4,
13.       "attrs": { "pins": "i2c" }
14.     },
15.     { "type": "wokwi-membrane-keypad", "id": "keypad1", "top": -21.2, "left": 101.6, "attrs": {} }
16.   ],
17.   "connections": [
18.     [ "esp:TX", "$serialMonitor:RX", "", [] ],
19.     [ "esp:RX", "$serialMonitor:TX", "", [] ],
20.     [ "servo1:GND", "esp:GND.2", "black", [ "h-67.2", "v105.6", "h144" ] ],
21.     [ "servo1:V+", "esp:5V", "red", [ "h-48", "v384.1" ] ],
22.     [ "servo1:PWM", "esp:15", "orange", [ "h-76.8", "v403.4", "h172.8", "v-57.6" ] ],
23.     [ "lcd1:GND", "esp:GND.2", "black", [ "h-105.6", "v115.2" ] ],
24.     [ "lcd1:VCC", "esp:5V", "red", [ "h-230.4", "v316.9" ] ],
25.     [ "keypad1:R4", "esp:5", "yellow", [ "v38.4", "h-221", "v-249.6" ] ],
26.     [ "keypad1:C1", "esp:17", "cyan", [ "v48", "h-163.3", "v-249.6" ] ],
27.     [ "keypad1:C2", "esp:16", "cyan", [ "v57.6", "h-201.6", "v-249.6" ] ],
28.     [ "keypad1:C3", "esp:4", "cyan", [ "v67.2", "h-201.75", "v-240", "h-76.8", "v-9.6" ] ],
29.     [ "keypad1:C4", "esp:2", "cyan", [ "v76.8", "h-201.9", "v-240" ] ],
30.     [ "keypad1:R1", "esp:23", "yellow", [ "v9.6", "h-172.8", "v-297.6" ] ],
31.     [ "lcd1:SDA", "esp:21", "blue", [ "h-96", "v182.6" ] ],
32.     [ "lcd1:SCL", "esp:22", "violet", [ "h-76.8", "v144.3" ] ],
33.     [ "keypad1:R2", "esp:19", "yellow", [ "v19.2", "h-192.4", "v-249.6" ] ],
34.     [ "keypad1:R3", "esp:18", "yellow", [ "v28.8", "h-221.1", "v-249.6" ] ]
35.   ],
36.   "dependencies": {}
37. }

